Index: note/UwithgpU.ipynb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 4,\n   \"outputs\": [],\n   \"source\": [\n    \"import numpy as np\\n\",\n    \"import matplotlib.pyplot as plt\\n\",\n    \"import qutip\\n\",\n    \"%matplotlib notebook\\n\",\n    \"from scipy.signal.windows import dpss\\n\",\n    \"from scipy.interpolate import interp1d\\n\",\n    \"import torch\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:24.468761Z\",\n     \"start_time\": \"2023-12-08T16:28:24.467054Z\"\n    }\n   },\n   \"id\": \"initial_id\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 5,\n   \"outputs\": [],\n   \"source\": [\n    \"if torch.backends.mps.is_available():\\n\",\n    \"    device = torch.device(\\\"mps\\\")\\n\",\n    \"else:\\n\",\n    \"    print (\\\"MPS device not found.\\\")\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:24.879448Z\",\n     \"start_time\": \"2023-12-08T16:28:24.876418Z\"\n    }\n   },\n   \"id\": \"32bf351665c1a177\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 6,\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"2.1.0.post100\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"print(torch.__version__)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:25.040297Z\",\n     \"start_time\": \"2023-12-08T16:28:25.037025Z\"\n    }\n   },\n   \"id\": \"29ef83d3db9f4844\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 7,\n   \"outputs\": [],\n   \"source\": [\n    \"def make_U_cuda(H, time_step, device='cuda'):\\n\",\n    \"    \\\"\\\"\\\"\\n\",\n    \"    Convert the function to utilize PyTorch and run on a GPU.\\n\",\n    \"\\n\",\n    \"    PARAMETERS\\n\",\n    \"        H : Tensor of shape (4,4) representing the time-dependent Hamiltonian\\n\",\n    \"        time_step : float, the time step for integration\\n\",\n    \"        device : string, the device to run the calculations on ('cuda' for GPU or 'cpu' for CPU)\\n\",\n    \"\\n\",\n    \"    RETURNS\\n\",\n    \"        U : function of t, which computes the unitary time evolution operator U(t)\\n\",\n    \"    \\\"\\\"\\\"\\n\",\n    \"    hbar = 1.  # Planck's constant (set to 1 for simplicity)\\n\",\n    \"    I = torch.eye(4, dtype=torch.complex128, device=device)  # Identity matrix\\n\",\n    \"\\n\",\n    \"    def U(t):\\n\",\n    \"        total = I  # U(t=0)\\n\",\n    \"        check = [I]\\n\",\n    \"        times = torch.arange(start=0, end=t, step=time_step, device=device)\\n\",\n    \"        for time in times:\\n\",\n    \"            derivative = (-1j / hbar) * torch.matmul(H(time), total) * time_step\\n\",\n    \"            total = total + derivative\\n\",\n    \"            check.append(total) \\n\",\n    \"        return total, np.array(check)\\n\",\n    \"    return U\\n\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:25.198398Z\",\n     \"start_time\": \"2023-12-08T16:28:25.196254Z\"\n    }\n   },\n   \"id\": \"718453241c4fc8b7\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 8,\n   \"outputs\": [],\n   \"source\": [\n    \"def make_H_int(g,delta_omega):\\n\",\n    \"    \\\"\\\"\\\"\\n\",\n    \"    \\n\",\n    \"    :param g: coupling strength\\n\",\n    \"    :param detuning: omega_q1 - omega_q2\\n\",\n    \"    :return: \\n\",\n    \"    \\\"\\\"\\\"\\n\",\n    \"    def H_int(t):\\n\",\n    \"        matrix=np.zeros((4,4),dtype=torch.complex128)\\n\",\n    \"        matrix[2][1] = np.exp((1j)*delta_omega*t)\\n\",\n    \"        matrix[1][2] = np.exp((-1j)*delta_omega*t)\\n\",\n    \"        return g(t)*matrix\\n\",\n    \"    return H_int\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:25.348849Z\",\n     \"start_time\": \"2023-12-08T16:28:25.346623Z\"\n    }\n   },\n   \"id\": \"542e2c948c010120\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 9,\n   \"outputs\": [],\n   \"source\": [\n    \"def make_H_d1(Omega,V_0,delta_omega,phi,s):\\n\",\n    \"    \\\"\\\"\\\"\\n\",\n    \"    :param Omega:  \\n\",\n    \"    :param V_0: \\n\",\n    \"    :param delta_omega:omega_q - omega_d \\n\",\n    \"    :param phi: offset in driving sine wave\\n\",\n    \"    :param s: control pulse\\n\",\n    \"    :return: \\n\",\n    \"    \\\"\\\"\\\"\\n\",\n    \"    I=np.identity(2,dtype=complex)\\n\",\n    \"\\n\",\n    \"    def H(t):\\n\",\n    \"        matrix=torch.tensor((2,2),device=device,dtype=torch.complex64)\\n\",\n    \"        matrix[0][1]=np.exp((1j)*(delta_omega*t+phi))\\n\",\n    \"        matrix[1][0]=np.exp((-1j)*(delta_omega*t+phi))\\n\",\n    \"    \\n\",\n    \"        return (-0.5)*Omega*V_0*s(t)*np.kron(matrix,I)\\n\",\n    \"    \\n\",\n    \"    return H #4by4 matrix\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:26.190277Z\",\n     \"start_time\": \"2023-12-08T16:28:26.186664Z\"\n    }\n   },\n   \"id\": \"b20ae6471f14095b\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 10,\n   \"outputs\": [\n    {\n     \"ename\": \"TypeError\",\n     \"evalue\": \"ones() received an invalid combination of arguments - got (tuple, dtype=builtin_function_or_method, device=torch.device), but expected one of:\\n * (tuple of ints size, *, tuple of names names, torch.dtype dtype, torch.layout layout, torch.device device, bool pin_memory, bool requires_grad)\\n * (tuple of ints size, *, Tensor out, torch.dtype dtype, torch.layout layout, torch.device device, bool pin_memory, bool requires_grad)\\n\",\n     \"output_type\": \"error\",\n     \"traceback\": [\n      \"\\u001B[0;31m---------------------------------------------------------------------------\\u001B[0m\",\n      \"\\u001B[0;31mTypeError\\u001B[0m                                 Traceback (most recent call last)\",\n      \"Cell \\u001B[0;32mIn[10], line 1\\u001B[0m\\n\\u001B[0;32m----> 1\\u001B[0m matrix\\u001B[38;5;241m=\\u001B[39mtorch\\u001B[38;5;241m.\\u001B[39mones((\\u001B[38;5;241m2\\u001B[39m,\\u001B[38;5;241m2\\u001B[39m),device\\u001B[38;5;241m=\\u001B[39mdevice,dtype\\u001B[38;5;241m=\\u001B[39mtorch\\u001B[38;5;241m.\\u001B[39mcomplex)\\n\",\n      \"\\u001B[0;31mTypeError\\u001B[0m: ones() received an invalid combination of arguments - got (tuple, dtype=builtin_function_or_method, device=torch.device), but expected one of:\\n * (tuple of ints size, *, tuple of names names, torch.dtype dtype, torch.layout layout, torch.device device, bool pin_memory, bool requires_grad)\\n * (tuple of ints size, *, Tensor out, torch.dtype dtype, torch.layout layout, torch.device device, bool pin_memory, bool requires_grad)\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"matrix=torch.ones((2,2),device=device,dtype=torch.complex)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:26.767223Z\",\n     \"start_time\": \"2023-12-08T16:28:26.626250Z\"\n    }\n   },\n   \"id\": \"85a299cedffb651\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 11,\n   \"outputs\": [],\n   \"source\": [\n    \"def make_H_d2(Omega,V_0,delta_omega,phi,s):\\n\",\n    \"    \\\"\\\"\\\"\\n\",\n    \"    :param Omega:  \\n\",\n    \"    :param V_0: \\n\",\n    \"    :param delta_omega:omega_q - omega_d \\n\",\n    \"    :param phi: offset in driving sine wave\\n\",\n    \"    :param s: control pulse\\n\",\n    \"    :return: \\n\",\n    \"    \\\"\\\"\\\"\\n\",\n    \"    I=np.identity(2,dtype=complex)\\n\",\n    \"    \\n\",\n    \"    def H(t):\\n\",\n    \"        matrix=np.zeros((2,2),dtype='complex128')\\n\",\n    \"        matrix[0][1]=np.exp((1j)*(delta_omega*t+phi))\\n\",\n    \"        matrix[1][0]=np.exp((-1j)*(delta_omega*t+phi))\\n\",\n    \"    \\n\",\n    \"        return (-0.5)*Omega*V_0*s(t)*np.kron(I,matrix)\\n\",\n    \"    \\n\",\n    \"    return H #4by4 matrix\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:26.940659Z\",\n     \"start_time\": \"2023-12-08T16:28:26.937296Z\"\n    }\n   },\n   \"id\": \"9add191151bd40e2\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 12,\n   \"outputs\": [],\n   \"source\": [\n    \"def g(t):\\n\",\n    \"    return 0.04*2*np.pi \\n\",\n    \"# 40MHz\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"ExecuteTime\": {\n     \"end_time\": \"2023-12-08T16:28:27.111468Z\",\n     \"start_time\": \"2023-12-08T16:28:27.107176Z\"\n    }\n   },\n   \"id\": \"bd3846979ebc15a7\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"def s(t):\\n\",\n    \"    return 1\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"88a499035ddc46dd\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"def slepian(t):\\n\",\n    \"    Fs = 10 #sampling rate 1ns에 10번 \\n\",\n    \"    N = 500\\n\",\n    \"    time = np.arange(N+1)/Fs \\n\",\n    \"    #freq = np.fft.fftfreq(N+1,d=1/Fs)\\n\",\n    \"    NW = 6    # Time-halfbandwidth product\\n\",\n    \"    # Generating the Slepian sequences\\n\",\n    \"    slepian_sequence = dpss(N+1, NW)\\n\",\n    \"    slepian_continuous = interp1d(time, slepian_sequence, kind='cubic')\\n\",\n    \"    return slepian_continuous(t)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"b343016ce2fa41df\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"Fs = 10 #sampling rate 1ns에 10번 \\n\",\n    \"N = 500\\n\",\n    \"time = np.arange(N+1)/Fs \\n\",\n    \"    #freq = np.fft.fftfreq(N+1,d=1/Fs)\\n\",\n    \"NW =  3   # Time-halfbandwidth product\\n\",\n    \"    # Generating the Slepian sequences\\n\",\n    \"slepian_sequence = dpss(N+1, NW)\\n\",\n    \"slepian_sequence2 = dpss(N+1, 6)\\n\",\n    \"fig, ax = plt.subplots()\\n\",\n    \"ax.plot(slepian_sequence)\\n\",\n    \"ax.plot(slepian_sequence2)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"d52ea56db17f31c3\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"#Setting\\n\",\n    \"omega1 = 0.01 * 2 * np.pi #10MHz\\n\",\n    \"omega2 = 0.01 * 2 * np.pi #10MHz\\n\",\n    \"V1=1.\\n\",\n    \"V2=1. #unit?\\n\",\n    \"delta_omega1 = 0.001 * 2 * np.pi #1MHz #qubit frequency and driving frequency\\n\",\n    \"delta_omega2 = 0.001 * 2 * np.pi #1MHz\\n\",\n    \"delta_q12 = 1 * 2 * np.pi # 1GHz\\n\",\n    \"phi1 = 0.001\\n\",\n    \"phi2 = 0.001\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"6be19978740e9cfa\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"H_int = make_H_int(g=g,delta_omega=delta_omega2) \\n\",\n    \"H_d1 = make_H_d1(Omega=omega1, V_0=V1,delta_omega=delta_omega1,s=slepian,phi=phi1)\\n\",\n    \"H_d2 = make_H_d2(Omega=omega2, V_0=V2,delta_omega=delta_omega2,s=slepian,phi=phi2)\\n\",\n    \"def H(t):\\n\",\n    \"    return H_int(t)+H_d1(t)+H_d2(t)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"9b3f01420ab73855\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"U = make_U(H, time_step=1e-4)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"586da179c863d67b\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"Uhigh = make_U(H, time_step=1e-5)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"f5504cafd83f15ff\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"transition, info = U(50.) #한번 돌리는데 4분30초...GPU로 계산하면 더 빠른가?\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"2b135f0461b55d\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"transition2, info2 = Uhigh(50.)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false,\n    \"is_executing\": true\n   },\n   \"id\": \"3cf66ad789534d34\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"np.save('1e-4_info.npy',info)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"35638968121f626a\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"trajectories=[]\\n\",\n    \"fig, ax = plt.subplots()\\n\",\n    \"ax.plot(np.arange(start=0,stop=50.+1e-4,step=1e-4),[u[1,0] for u in info])\\n\",\n    \"    \"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"d02a90c75f3008c8\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"unitary_check=np.matmul(np.matrix.getH(transition),transition)\\n\",\n    \"unitary_check\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"88166d94748ae3b\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"#prepare qubit 1 in e \\n\",\n    \"initial_state = np.array([0,0,1.,0,], dtype=complex)\\n\",\n    \"desired_state = np.array([0,1.,0,0,], dtype=complex)\\n\",\n    \"\\n\",\n    \"iSWAP=np.zeros((4,4),dtype=complex)\\n\",\n    \"iSWAP[0,0]=1.\\n\",\n    \"iSWAP[3,3]=1.\\n\",\n    \"iSWAP[2,1]=-1j\\n\",\n    \"iSWAP[1,2]=-1j\\n\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"e6daa347ed839f8f\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"trans_state=np.matmul(iSWAP,initial_state)\\n\",\n    \"np.matmul(np.matrix.getH(desired_state),trans_state)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"cefcafbd8acf47ca\"\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"source\": [\n    \"$$s_1(t),\\\\ s_2(t), g(t)$$\\n\",\n    \"\\n\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"99aeae190f40d3b1\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"np.matrix.getH(desired_state)\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"f0b4ac664b874bad\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [\n    \"trans_state\"\n   ],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"8bbb60f88f35a24d\"\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"outputs\": [],\n   \"source\": [],\n   \"metadata\": {\n    \"collapsed\": false\n   },\n   \"id\": \"502c6d04ccc86a00\"\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 2\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython2\",\n   \"version\": \"2.7.6\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n
===================================================================
diff --git a/note/UwithgpU.ipynb b/note/UwithgpU.ipynb
--- a/note/UwithgpU.ipynb	
+++ b/note/UwithgpU.ipynb	
@@ -393,9 +393,7 @@
    "cell_type": "code",
    "execution_count": null,
    "outputs": [],
-   "source": [
-    "np.save('1e-4_info.npy',info)"
-   ],
+   "source": [],
    "metadata": {
     "collapsed": false
    },
